/*
  Copyright (c) 2016 DataStax, Inc.

  This software can be used solely with DataStax Enterprise. Please consult the
  license at http://www.datastax.com/terms/datastax-dse-driver-license-terms
*/

#ifndef __TEST_SESSION_HPP__
#define __TEST_SESSION_HPP__
#include "cassandra.h"

#include "objects/object_base.hpp"

#include "objects/future.hpp"
#include "objects/prepared.hpp"
#include "objects/result.hpp"
#include "objects/statement.hpp"

#include "exception.hpp"

namespace test {
namespace driver {

/**
 * Wrapped session object
 */
class Session : public Object<CassSession, cass_session_free> {
friend class Cluster;
public:
  class Exception : public test::CassException {
  public:
    Exception(const std::string& message, const CassError error_code)
      : test::CassException(message, error_code) {}
  };

  /**
   * Create the default session object
   */
  Session()
    : Object<CassSession, cass_session_free>(cass_session_new()) {}

  /**
   * Create the session object from the native driver object
   *
   * @param session Native driver object
   */
  Session(CassSession* session)
    : Object<CassSession, cass_session_free>(session) {}

  /**
   * Create the session object from a shared reference
   *
   * @param session Shared reference
   */
  Session(Ptr session)
    : Object<CassSession, cass_session_free>(session) {}

  /**
   * Close the active session
   *
   * @param assert_ok True if error code for future should be asserted
   *                  CASS_OK; false otherwise (default: true)
   */
  void close(bool assert_ok = true) {
    Future close_future = cass_session_close(get());
    close_future.wait(assert_ok);
  }

  /**
   * Execute a batch statement synchronously
   *
   * @param batch Batch statement to execute
   * @param assert_ok True if error code for future should be asserted
   *                  CASS_OK; false otherwise (default: true)
   */
  void execute(Batch batch, bool assert_ok = true) {
    Future future(cass_session_execute_batch(get(), batch.get()));
    future.wait(assert_ok);
  }

  /**
   * Execute a statement synchronously
   *
   * @param statement Query or bound statement to execute
   * @param assert_ok True if error code for future should be asserted
   *                  CASS_OK; false otherwise (default: true)
   * @return Result object
   */
  Result execute(Statement statement, bool assert_ok = true) {
    Future future(cass_session_execute(get(), statement.get()));
    future.wait(assert_ok);
    return Result(future);
  }

  /**
   * Execute a query synchronously
   *
   * @param query Query to execute as a simple statement
   * @param consistency Consistency level to execute the query at
   *                    (default: CASS_CONSISTENCY_LOCAL_ONE)
   * @param assert_ok True if error code for future should be asserted
   *                  CASS_OK; false otherwise (default: true)
   * @return Result object
   */
  Result execute(const std::string& query,
    CassConsistency consistency = CASS_CONSISTENCY_LOCAL_ONE,
    bool assert_ok = true) {
    Statement statement(cass_statement_new(query.c_str(), 0));
    EXPECT_EQ(CASS_OK, cass_statement_set_consistency(statement.get(),
      consistency));
    return execute(statement, assert_ok);
  }

  /**
   * Execute a batch statement asynchronously
   *
   * @param batch Batch statement to execute
   * @return Future object
   */
  Future execute_async(Batch batch) {
    return Future(cass_session_execute_batch(get(), batch.get()));
  }

  /**
   * Execute a statement asynchronously
   *
   * @param statement Query or bound statement to execute
   * @return Future object
   */
  Future execute_async(Statement statement) {
    return Future(cass_session_execute(get(), statement.get()));
  }

  /**
   * Execute a query asynchronously
   *
   * @param query Query to execute as a simple statement
   * @param consistency Consistency level to execute the query at
   *                    (default: CASS_CONSISTENCY_LOCAL_ONE)
   * @return Future object
   */
  Future execute_async(const std::string& query,
    CassConsistency consistency = CASS_CONSISTENCY_LOCAL_ONE) {
    Statement statement(cass_statement_new(query.c_str(), 0));
    EXPECT_EQ(CASS_OK, cass_statement_set_consistency(statement.get(),
      consistency));
    return execute_async(statement);
  }

  /**
   * Create a prepared statement
   *
   * @param query The query to prepare
   * @param assert_ok True if error code for future should be asserted
   *                  CASS_OK; false otherwise (default: true)
   * @return Prepared statement generated by the server for the query
   */
  Prepared prepare(const std::string& query, bool assert_ok = true) {
    Future prepare_future = cass_session_prepare(get(), query.c_str());
    prepare_future.wait(assert_ok);
    return Prepared(cass_future_get_prepared(prepare_future.get()));
  }

protected:
  /**
   * Create a new session and establish a connection to the server;
   * synchronously
   *
   * @param cluster Cluster configuration to use when establishing
   *                connection
   * @param keyspace Keyspace to use (default: None)
   * @return Session object
   * @throws Session::Exception If session could not be established
   */
  static Session connect(CassCluster* cluster, const std::string& keyspace) {
    Session session;
    Future connect_future;
    if (keyspace.empty()) {
      connect_future = Future(cass_session_connect(session.get(), cluster));
    } else {
      connect_future = Future(cass_session_connect_keyspace(session.get(),
        cluster, keyspace.c_str()));
    }
    connect_future.wait(false);
    if (connect_future.error_code() != CASS_OK) {
      throw Exception("Unable to Establish Session Connection: "
          + connect_future.error_description(), connect_future.error_code());
    }
    return session;
  }
};

} // namespace driver
} // namespace test

#endif // __TEST_SESSION_HPP__
